<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C++复健</title>
      <link href="/2025/10/02/C++%E5%A4%8D%E5%BB%BA/"/>
      <url>/2025/10/02/C++%E5%A4%8D%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>都是一些零散的知识，梦到哪里记到哪。。。</p><h2 id="1-最大公约数算法原理"><a href="#1-最大公约数算法原理" class="headerlink" title="1.最大公约数算法原理"></a>1.最大公约数算法原理</h2><ul><li>首先，老师上课讲过，但是好像并没有听懂，今天重刷洛谷时候感觉对这方面不是很熟。<br>这个方法来自欧几里得的<strong>辗转相除法</strong>。代码实现如下：</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gcd</span>(a,b)&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>辗转相除法：</strong></p><ul><li><p>实际上，这是高等代数讲过的问题，就是最大公约数和最大公约数的区别。先回忆一下高代中的知识。</p></li><li><p><strong>定理：</strong><br>在多项式环 $P[x]$ 中，任意两个多项式 $f(x)$ 和 $g(x)$ 都存在最大公因式。<br>而且，$f(x)$ 和 $g(x)$ 的任意一个最大公因式 $d(x)$ 都可以表示为 $f(x)$ 和 $g(x)$ 的线性组合，即存在 $u(x), v(x) \in P[x]$，使得：</p></li></ul><p>$$<br>d(x) &#x3D; u(x)f(x) + v(x)g(x)<br>$$</p><ul><li>证明如下图所示：<br><img src="https://github.com/Xun-cmd/picgo_picture/blob/main/img/C++%E5%A4%8D%E5%81%A5/1c140b292d0c0102e68b3200619ed0da.jpg?raw=true" alt="1.jpg"><br>由上述定理，我们可以知道f(x),g(x)的最大公因式一定存在，接下来我们看用辗转相除法的原理证明（题外话,,这成高代笔记了。。）：<br><img src="https://github.com/Xun-cmd/picgo_picture/blob/main/img/C++%E5%A4%8D%E5%81%A5/gaodai2.jpg?raw=true" alt="2.jpg"><br>小红书大佬的辗转相除法证明：<br><img src="https://github.com/Xun-cmd/picgo_picture/blob/main/img/C++%E5%A4%8D%E5%81%A5/zhanzhuan.jpg?raw=true" alt="3.jpg"><br>那我们回过头看，令 a%b&#x3D;r，这段代码的含义就是如果 b 不等于0，函数就返回 gcd(b,r)，直到b&#x3D;0，此时的a就是图二中的 r<sub>s</sub>(x).</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">gcd</span>(a,b)&#123;</span><br><span class="line">    <span class="keyword">return</span> b == <span class="number">0</span> ? a : <span class="built_in">gcd</span>(b, a % b);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-同余原理"><a href="#2-同余原理" class="headerlink" title="2.同余原理"></a>2.同余原理</h2><p><strong>定义：</strong>  </p><ul><li>如果两个整数 $a$ 和 $b$，以及一个正整数 $m$，满足 $a \equiv b \pmod{m}$，则称 $a$ 与 $b$ 在模 $m$ 意义下同余。<br>也就是说，$a$ 和 $b$ 除以 $m$ 后余数相同，或者 $m$ 能整除 $a-b$。<br><strong>举例：</strong><br>$17 \equiv 5 \pmod{12}$，因为 $17 - 5 &#x3D; 12$ 能被 $12$ 整除。<br>相当于：$a-b&#x3D;km$，或者$a&#x3D;b+km$.</li></ul><p><strong>性质：</strong></p><ul><li>同余关系具有传递性、对称性和自反性。（离散数学）</li><li>如果 $a \equiv b \pmod{m}$，则 $a + c \equiv b + c \pmod{m}$，$a \cdot c \equiv b \cdot c \pmod{m}$。</li></ul><p><strong>应用：</strong></p><ul><li>常用于简化大数运算，比如快速判断某个数能否被整除。</li><li>在密码学、算法竞赛、程序设计等领域广泛应用。</li></ul><p><strong>例题：</strong></p><ul><li><p>2003年5月9日是星期五，问第 $2^{2003}$ 天是星期几？<br><strong>解题思路：</strong></p><p>一周有 7 天，星期几每 7 天循环一次，所以只需计算 $2^{2003}$ 除以 7 的余数。</p><p><strong>计算 $2^{2003} \bmod 7$：</strong></p><p>注意到 $2^3 \equiv 1 \pmod{7}$，所以 $2^{2003} &#x3D; 2^{3 \times 667 + 2} &#x3D; (2^3)^{667} \times 2^2 \equiv 1^{667} \times 4 \equiv 4 \pmod{7}$。</p><p><strong>推算星期几：</strong></p><p>第 1 天是星期五，第 $2^{2003}$ 天是星期五后的第 4 天：</p><ul><li>星期五 + 1 天 &#x3D; 星期六</li><li>星期五 + 2 天 &#x3D; 星期日</li><li>星期五 + 3 天 &#x3D; 星期一</li><li>星期五 + 4 天 &#x3D; 星期二</li></ul><p><strong>答：第 $2^{2003}$ 天是星期二。</strong></p></li></ul><p><strong>编程题目：</strong></p><p> <img src="https://github.com/Xun-cmd/picgo_picture/blob/main/img/C++%E5%A4%8D%E5%81%A5/lianxi.png?raw=true" alt="lianxi.png"></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="type">int</span> x, n;</span><br><span class="line">    cin &gt;&gt; x &gt;&gt; n;</span><br><span class="line">    <span class="type">int</span> days = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; n; ++i) &#123;</span><br><span class="line">        <span class="type">int</span> currentDay = (x + i - <span class="number">1</span>) % <span class="number">7</span> + <span class="number">1</span>; </span><br><span class="line">        <span class="keyword">if</span> (currentDay != <span class="number">6</span> &amp;&amp; currentDay != <span class="number">7</span>) &#123;</span><br><span class="line">            days += <span class="number">250</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; days &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>上述代码为题解，其中，关键点是天数的确定</li></ul><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> currentDay = (x + i - <span class="number">1</span>) % <span class="number">7</span> + <span class="number">1</span>; </span><br></pre></td></tr></table></figure><ul><li>关键就在于这行代码，这里通过对 7 取模（% 7），实现了星期的循环计算。因为一周有 7 天，星期几每 7 天循环一次，所以用模运算可以得到当前是星期几，这正是同余原理在实际编程中的应用。现在我们来仔细解读这段代码<ul><li>x+i-1：<br> x 是起始星期几，比如星期五就是 5。<br>i 是循环变量，表示第几天（第 0 天、第 1 天……）。<br>x + i - 1 这样写是为了让第 0 天就是起始星期几，第 1 天是起始星期几的下一天，以此类推。</li><li>如果没有 -1，比如 currentDay &#x3D; (x + i) % 7 + 1，那么当 i &#x3D; 0 时，结果是 x + 0，也就是第 1 天是星期 x+1，这样会错位一天。</li><li>+1：因为 % 7 得到的是 0-6，而星期几通常用 1-7 表示，所以最后加 1，把结果变成 1-7。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编程 </tag>
            
            <tag> 入门 </tag>
            
            <tag> 算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>链表的学习</title>
      <link href="/2025/09/24/%E9%93%BE%E8%A1%A8%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/09/24/%E9%93%BE%E8%A1%A8%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="说在前面"><a href="#说在前面" class="headerlink" title="说在前面"></a>说在前面</h1><p>这是一个绝望的女大学生学习数据结构的笔记，参考了B站up主<strong>秒懂算法</strong>大佬的数据结构教程，只是留着以后复习用，接下来是我的笔记啦！😋</p><h1 id="ADT"><a href="#ADT" class="headerlink" title="ADT"></a>ADT</h1><p>抽象数据类型（Abstract Data Type，ADT）是计算机科学中具有类似行为的特定类别的数据结构的数学模型；或者具有类似语义的一种或多种程序设计语言的数据类型。抽象数据类型是描述数据结构的一种理论工具，其目的是使人们能够独立于程序的实现细节来理解数据结构的特性。抽象数据类型的定义取决于它的一组逻辑特性，而与计算机内部如何表示无关。</p><h1 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h1><p>概念理解：前驱，后继，指针域，数据域<br>链表由一系列不必在内存中相连的结构组成（与数组有区别），每一个结构都含有表元素和指向包含该元素后继元的结构的指针，我们称之为Next指针，最后一个Next指针指向NULL。了解定义之后，就开始学习插入删除的方法吧。</p><h2 id="初始化链表"><a href="#初始化链表" class="headerlink" title="初始化链表"></a>初始化链表</h2><p>首先，我们要初始化一个链表，创建一个结构体，定义其中的数据域、指针域。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">Node</span> &#123;</span><br><span class="line">    <span class="type">int</span> data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="keyword">struct</span> <span class="title class_">Node</span>* next;<span class="comment">//下一节点地址</span></span><br><span class="line">&#125; Node;   <span class="comment">//初始化链表，相当于创建一个头节点</span></span><br></pre></td></tr></table></figure><h2 id="头节点初始化函数"><a href="#头节点初始化函数" class="headerlink" title="头节点初始化函数"></a>头节点初始化函数</h2><p>然后，我们要对头节点进行初始化，在堆内存中分配node节点，将数据域初始化为0，next指针指向NULL。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">Node* <span class="title">initializeHeadNode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));<span class="comment">//在堆内存分配node节点</span></span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;<span class="comment">//分配失败，返回NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = <span class="number">0</span>;<span class="comment">//数据域初始化为0</span></span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;<span class="comment">//next空指针初始化为空</span></span><br><span class="line">    <span class="keyword">return</span> newNode;<span class="comment">//返回头节点地址</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="插入方法"><a href="#插入方法" class="headerlink" title="插入方法"></a>插入方法</h2><p>在课程中，我学习到了三种插法</p><h3 id="头插法"><a href="#头插法" class="headerlink" title="头插法"></a>头插法</h3><p>头插法，就是在链表的开头插入新元素，但是一般新元素要在头节点的后面。<br>下面来看代码,代码中我们可以看到，在insertAtHead函数中，有两个参数，Node* head是指向链表头节点的指针，int value是要插入的新节点的数据值。第一行代码，首先声明一个Node<em>类型的指针newNode，用于指向新创建的节点*<em>调用malloc函数分配一块内存，大小为Node结构体的大小（即一个节点所需的内存空间）</em></em><br>需要注意的是：(Node*)是强制类型转换，将malloc返回的void<em>指针转换为Node</em>类型，以便正确指向节点结构体。<br>这一步的目的是为新节点申请内存空间。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertAtHead</span><span class="params">(Node* head, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));<span class="comment">//</span></span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;failure\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;<span class="comment">//内存分配成功就将传入的value赋值给新节点的data成员</span></span><br><span class="line">    newNode-&gt;next = head-&gt;next;<span class="comment">//新节点指向原来的第一个节点</span></span><br><span class="line">    head-&gt;next = newNode;<span class="comment">//头节点指向新节点</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;success,data is:%d\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="尾插法"><a href="#尾插法" class="headerlink" title="尾插法"></a>尾插法</h3><p>其余详细解释在头插法已经说过，此处不再赘述</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertAtTail</span><span class="params">(Node* head, <span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">    <span class="keyword">if</span> (newNode == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;内存分配失败\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    newNode-&gt;next = <span class="literal">NULL</span>;<span class="comment">//新节点成为尾节点，next指向空</span></span><br><span class="line"></span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        current = current-&gt;next;<span class="comment">//找到最后一个节点</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将新节点插入链表尾部</span></span><br><span class="line">    current-&gt;next = newNode;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;成功在尾部插入节点，数据为： %d\n&quot;</span>, value);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="指定位置插入节点"><a href="#指定位置插入节点" class="headerlink" title="指定位置插入节点"></a>指定位置插入节点</h3><p>和前面两个插入方法差不多，但是这里要注意顺序不能写反，这里面还需要注意的是，我们需要确定插入的位置，因此此处增加了一个参数position，函数中增加一个循环，没有找到制定的位置时，此时的current就会指向自己的next，直到倒找要插入的元素前一位。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insertAtPosition</span><span class="params">(Node* head, <span class="type">int</span> value, <span class="type">int</span> position)</span> </span>&#123;</span><br><span class="line">    Node* newNode = (Node*)<span class="built_in">malloc</span>(<span class="built_in">sizeof</span>(Node));</span><br><span class="line">    newNode-&gt;data = value;</span><br><span class="line">    <span class="comment">//找到要插入位置的前一个结点</span></span><br><span class="line">    Node* current = head;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (count &lt; position - <span class="number">1</span>) &#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">        count++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//插入新节点</span></span><br><span class="line">    newNode-&gt;next = current-&gt;next;</span><br><span class="line">    current-&gt;next = newNode;<span class="comment">//顺序不可以写反</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编程 </tag>
            
            <tag> 入门 </tag>
            
            <tag> 算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机实践学习(第一周)</title>
      <link href="/2025/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0/"/>
      <url>/2025/07/07/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%AE%9E%E8%B7%B5%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="TDD结构"><a href="#TDD结构" class="headerlink" title="TDD结构"></a>TDD结构</h1><p>TDD（Test-Driven Development，测试驱动开发），核心思想是<strong>先写测试，再写代码</strong>。<br>这次我们将通过fizzbuzz这个例子来辅助理解</p><h2 id="红绿结构"><a href="#红绿结构" class="headerlink" title="红绿结构"></a>红绿结构</h2><p>1.红（red）：即编写一个错误的测试用例，先写测试代码，此时由于没有实现对应的功能，测试失败，变为红色。<br>2.绿（green）：即编写一个正确的测试用例，此时实现了对应功能，测试成功，变为绿色。<br>3.重构（refactor）：在不改变代码功能的前提下，优化代码结构，同时保持测试通过。</p><h1 id="fizzbuzz函数的编写"><a href="#fizzbuzz函数的编写" class="headerlink" title="fizzbuzz函数的编写"></a>fizzbuzz函数的编写</h1><h2 id="头文件"><a href="#头文件" class="headerlink" title="头文件"></a>头文件</h2><p><strong>fizzbuzz.h</strong></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="function">std::string <span class="title">fizzBuzz</span><span class="params">(<span class="type">int</span> value)</span></span>;</span><br></pre></td></tr></table></figure><h2 id="cpp文件"><a href="#cpp文件" class="headerlink" title="cpp文件"></a>cpp文件</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span> <span class="comment">//后面解释</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fizzbuzz.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function">std::string <span class="title">fizzBuzz</span><span class="params">(<span class="type">int</span> value)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (value % <span class="number">3</span> == <span class="number">0</span> &amp;&amp; value % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;FizzBuzz&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value % <span class="number">3</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Fizz&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (value % <span class="number">5</span> == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">&quot;Buzz&quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> std::<span class="built_in">to_string</span>(value);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> value;</span><br><span class="line">    cin &gt;&gt; value;</span><br><span class="line">    cout &lt;&lt; <span class="built_in">fizzBuzz</span>(value) &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="测试用例的编写"><a href="#测试用例的编写" class="headerlink" title="测试用例的编写"></a>测试用例的编写</h1><h2 id="vs2022中的测试管理系统"><a href="#vs2022中的测试管理系统" class="headerlink" title="vs2022中的测试管理系统"></a>vs2022中的测试管理系统</h2><p>1.fizzbuzz_test.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span> <span class="comment">//预编译头文件</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fizzbuzz.h&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;CppUnitTest.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> Microsoft::VisualStudio::CppUnitTestFramework;</span><br><span class="line"></span><br><span class="line"><span class="keyword">namespace</span> fizzbuzztest</span><br><span class="line">&#123;</span><br><span class="line"><span class="built_in">TEST_CLASS</span>(fizzbuzztest)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line"></span><br><span class="line"><span class="built_in">TEST_METHOD</span>(TestMethod1)</span><br><span class="line">&#123;</span><br><span class="line">Assert::<span class="built_in">AreEqual</span>(std::<span class="built_in">string</span>(<span class="string">&quot;1&quot;</span>), <span class="built_in">fizzBuzz</span>(<span class="number">1</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST_METHOD</span>(TestMethod2)</span><br><span class="line">&#123;</span><br><span class="line">Assert::<span class="built_in">AreEqual</span>(std::<span class="built_in">string</span>(<span class="string">&quot;2&quot;</span>), <span class="built_in">fizzBuzz</span>(<span class="number">2</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST_METHOD</span>(TestMethod3)</span><br><span class="line">&#123;</span><br><span class="line">Assert::<span class="built_in">AreEqual</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Fizz&quot;</span>), <span class="built_in">fizzBuzz</span>(<span class="number">3</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST_METHOD</span>(TestMethod4)</span><br><span class="line">&#123;</span><br><span class="line">Assert::<span class="built_in">AreEqual</span>(std::<span class="built_in">string</span>(<span class="string">&quot;4&quot;</span>), <span class="built_in">fizzBuzz</span>(<span class="number">4</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST_METHOD</span>(TestMethod5)</span><br><span class="line">&#123;</span><br><span class="line">Assert::<span class="built_in">AreEqual</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Buzz&quot;</span>), <span class="built_in">fizzBuzz</span>(<span class="number">5</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST_METHOD</span>(TestMethod6)</span><br><span class="line">&#123;</span><br><span class="line">Assert::<span class="built_in">AreEqual</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Fizz&quot;</span>), <span class="built_in">fizzBuzz</span>(<span class="number">6</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST_METHOD</span>(TestMethod7)</span><br><span class="line">&#123;</span><br><span class="line">Assert::<span class="built_in">AreEqual</span>(std::<span class="built_in">string</span>(<span class="string">&quot;7&quot;</span>), <span class="built_in">fizzBuzz</span>(<span class="number">7</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST_METHOD</span>(TestMethod8)</span><br><span class="line">&#123;</span><br><span class="line">Assert::<span class="built_in">AreEqual</span>(std::<span class="built_in">string</span>(<span class="string">&quot;8&quot;</span>), <span class="built_in">fizzBuzz</span>(<span class="number">8</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST_METHOD</span>(TestMethod9)</span><br><span class="line">&#123;</span><br><span class="line">Assert::<span class="built_in">AreEqual</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Fizz&quot;</span>), <span class="built_in">fizzBuzz</span>(<span class="number">9</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST_METHOD</span>(TestMethod10)</span><br><span class="line">&#123;</span><br><span class="line">Assert::<span class="built_in">AreEqual</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Buzz&quot;</span>), <span class="built_in">fizzBuzz</span>(<span class="number">10</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST_METHOD</span>(TestMethod11)</span><br><span class="line">&#123;</span><br><span class="line">Assert::<span class="built_in">AreEqual</span>(std::<span class="built_in">string</span>(<span class="string">&quot;11&quot;</span>), <span class="built_in">fizzBuzz</span>(<span class="number">11</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST_METHOD</span>(TestMethod12)</span><br><span class="line">&#123;</span><br><span class="line">Assert::<span class="built_in">AreEqual</span>(std::<span class="built_in">string</span>(<span class="string">&quot;Fizz&quot;</span>), <span class="built_in">fizzBuzz</span>(<span class="number">12</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST_METHOD</span>(TestMethod13)</span><br><span class="line">&#123;</span><br><span class="line">Assert::<span class="built_in">AreEqual</span>(std::<span class="built_in">string</span>(<span class="string">&quot;13&quot;</span>), <span class="built_in">fizzBuzz</span>(<span class="number">13</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST_METHOD</span>(TestMethod14)</span><br><span class="line">&#123;</span><br><span class="line">Assert::<span class="built_in">AreEqual</span>(std::<span class="built_in">string</span>(<span class="string">&quot;14&quot;</span>), <span class="built_in">fizzBuzz</span>(<span class="number">14</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">TEST_METHOD</span>(TestMethod15)</span><br><span class="line">&#123;</span><br><span class="line">Assert::<span class="built_in">AreEqual</span>(std::<span class="built_in">string</span>(<span class="string">&quot;FizzBuzz&quot;</span>), <span class="built_in">fizzBuzz</span>(<span class="number">15</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>2.pch.h</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">ifndef</span> PCH_H</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PCH_H</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 添加要在此处预编译的标头</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span> </span></span><br></pre></td></tr></table></figure><p>3.pch.cpp</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;pch.h&quot;</span></span></span><br><span class="line"><span class="comment">// 当使用预编译的头时，需要使用此源文件，编译才能成功。</span></span><br></pre></td></tr></table></figure><h1 id="用例运行"><a href="#用例运行" class="headerlink" title="用例运行"></a>用例运行</h1><p>在vs2022页面上面找到测试，点击，出现测试资源管理器，点击，出现一个绿色小三角，点击旁边的白色倒三角，出现运行全部测试用例，接着点击即可。<br>过一会就会出现测试通过的界面了~<br><img src="/img/%E8%BF%90%E8%A1%8C%E5%9B%BE%E7%89%87.png" alt="示例图片" title="测试完成如图所示"></p>]]></content>
      
      
      <categories>
          
          <category> C++学习 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> C++ </tag>
            
            <tag> 编程 </tag>
            
            <tag> 基础 </tag>
            
            <tag> 入门 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自我介绍</title>
      <link href="/2025/02/20/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/"/>
      <url>/2025/02/20/%E8%87%AA%E6%88%91%E4%BB%8B%E7%BB%8D/</url>
      
        <content type="html"><![CDATA[<h3 id="自我介绍"><a href="#自我介绍" class="headerlink" title="自我介绍"></a>自我介绍</h3><p>我是秃头的君寻酱，喜欢打游戏、看动漫，最喜欢的游戏是重返未来1999，欢迎同好找我玩喵<br>我还是一名计算机专业的大一新生，希望通过博客来分享我的学习过程和日常的活动(✿◡‿◡)<br>本人是一名小白，欢迎各位大佬多多指教~~~&#x2F;(^v^)~~~</p><h3 id="对未来的展望"><a href="#对未来的展望" class="headerlink" title="对未来的展望"></a>对未来的展望</h3><p>对于我自己来说的话，目前还没有分流，我也不知道以后的方向是什么，希望一直坚持走下去吧<br>目前对3d建模这个行业比较向往，如果可以的话，希望能保上研 但是真的很难&#x2F;(ㄒoㄒ)&#x2F;~~</p><h3 id="学习的语言"><a href="#学习的语言" class="headerlink" title="学习的语言"></a>学习的语言</h3><p>目前只学习了c++，学的还不够好，这学期一定会加油的</p><h3 id="爱好"><a href="#爱好" class="headerlink" title="爱好"></a>爱好</h3><p>打游戏，看动漫，画画，目前最喜欢的角色是逻各斯(❤ ω ❤)</p>]]></content>
      
      
      
        <tags>
            
            <tag> 生活 </tag>
            
            <tag> 杂谈 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
